// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"mylittleprice/ent/chatsession"
	"mylittleprice/ent/message"
	"mylittleprice/ent/predicate"
	"mylittleprice/ent/searchhistory"
	"mylittleprice/ent/user"
	"mylittleprice/ent/userpreference"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeChatSession    = "ChatSession"
	TypeMessage        = "Message"
	TypeSearchHistory  = "SearchHistory"
	TypeUser           = "User"
	TypeUserPreference = "UserPreference"
)

// ChatSessionMutation represents an operation that mutates the ChatSession nodes in the graph.
type ChatSessionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	session_id           *string
	country_code         *string
	language_code        *string
	currency             *string
	message_count        *int
	addmessage_count     *int
	search_state         *map[string]interface{}
	cycle_state          *map[string]interface{}
	conversation_context *map[string]interface{}
	created_at           *time.Time
	updated_at           *time.Time
	expires_at           *time.Time
	clearedFields        map[string]struct{}
	user                 *uuid.UUID
	cleareduser          bool
	messages             map[uuid.UUID]struct{}
	removedmessages      map[uuid.UUID]struct{}
	clearedmessages      bool
	done                 bool
	oldValue             func(context.Context) (*ChatSession, error)
	predicates           []predicate.ChatSession
}

var _ ent.Mutation = (*ChatSessionMutation)(nil)

// chatsessionOption allows management of the mutation configuration using functional options.
type chatsessionOption func(*ChatSessionMutation)

// newChatSessionMutation creates new mutation for the ChatSession entity.
func newChatSessionMutation(c config, op Op, opts ...chatsessionOption) *ChatSessionMutation {
	m := &ChatSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeChatSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChatSessionID sets the ID field of the mutation.
func withChatSessionID(id uuid.UUID) chatsessionOption {
	return func(m *ChatSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *ChatSession
		)
		m.oldValue = func(ctx context.Context) (*ChatSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChatSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChatSession sets the old ChatSession of the mutation.
func withChatSession(node *ChatSession) chatsessionOption {
	return func(m *ChatSessionMutation) {
		m.oldValue = func(context.Context) (*ChatSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChatSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChatSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChatSession entities.
func (m *ChatSessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChatSessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChatSessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChatSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSessionID sets the "session_id" field.
func (m *ChatSessionMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *ChatSessionMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the ChatSession entity.
// If the ChatSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatSessionMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *ChatSessionMutation) ResetSessionID() {
	m.session_id = nil
}

// SetUserID sets the "user_id" field.
func (m *ChatSessionMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ChatSessionMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ChatSession entity.
// If the ChatSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatSessionMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ChatSessionMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[chatsession.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ChatSessionMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[chatsession.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ChatSessionMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, chatsession.FieldUserID)
}

// SetCountryCode sets the "country_code" field.
func (m *ChatSessionMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *ChatSessionMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the ChatSession entity.
// If the ChatSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatSessionMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *ChatSessionMutation) ResetCountryCode() {
	m.country_code = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *ChatSessionMutation) SetLanguageCode(s string) {
	m.language_code = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *ChatSessionMutation) LanguageCode() (r string, exists bool) {
	v := m.language_code
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the ChatSession entity.
// If the ChatSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatSessionMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *ChatSessionMutation) ResetLanguageCode() {
	m.language_code = nil
}

// SetCurrency sets the "currency" field.
func (m *ChatSessionMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *ChatSessionMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the ChatSession entity.
// If the ChatSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatSessionMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *ChatSessionMutation) ResetCurrency() {
	m.currency = nil
}

// SetMessageCount sets the "message_count" field.
func (m *ChatSessionMutation) SetMessageCount(i int) {
	m.message_count = &i
	m.addmessage_count = nil
}

// MessageCount returns the value of the "message_count" field in the mutation.
func (m *ChatSessionMutation) MessageCount() (r int, exists bool) {
	v := m.message_count
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageCount returns the old "message_count" field's value of the ChatSession entity.
// If the ChatSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatSessionMutation) OldMessageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageCount: %w", err)
	}
	return oldValue.MessageCount, nil
}

// AddMessageCount adds i to the "message_count" field.
func (m *ChatSessionMutation) AddMessageCount(i int) {
	if m.addmessage_count != nil {
		*m.addmessage_count += i
	} else {
		m.addmessage_count = &i
	}
}

// AddedMessageCount returns the value that was added to the "message_count" field in this mutation.
func (m *ChatSessionMutation) AddedMessageCount() (r int, exists bool) {
	v := m.addmessage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetMessageCount resets all changes to the "message_count" field.
func (m *ChatSessionMutation) ResetMessageCount() {
	m.message_count = nil
	m.addmessage_count = nil
}

// SetSearchState sets the "search_state" field.
func (m *ChatSessionMutation) SetSearchState(value map[string]interface{}) {
	m.search_state = &value
}

// SearchState returns the value of the "search_state" field in the mutation.
func (m *ChatSessionMutation) SearchState() (r map[string]interface{}, exists bool) {
	v := m.search_state
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchState returns the old "search_state" field's value of the ChatSession entity.
// If the ChatSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatSessionMutation) OldSearchState(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchState: %w", err)
	}
	return oldValue.SearchState, nil
}

// ResetSearchState resets all changes to the "search_state" field.
func (m *ChatSessionMutation) ResetSearchState() {
	m.search_state = nil
}

// SetCycleState sets the "cycle_state" field.
func (m *ChatSessionMutation) SetCycleState(value map[string]interface{}) {
	m.cycle_state = &value
}

// CycleState returns the value of the "cycle_state" field in the mutation.
func (m *ChatSessionMutation) CycleState() (r map[string]interface{}, exists bool) {
	v := m.cycle_state
	if v == nil {
		return
	}
	return *v, true
}

// OldCycleState returns the old "cycle_state" field's value of the ChatSession entity.
// If the ChatSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatSessionMutation) OldCycleState(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCycleState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCycleState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCycleState: %w", err)
	}
	return oldValue.CycleState, nil
}

// ResetCycleState resets all changes to the "cycle_state" field.
func (m *ChatSessionMutation) ResetCycleState() {
	m.cycle_state = nil
}

// SetConversationContext sets the "conversation_context" field.
func (m *ChatSessionMutation) SetConversationContext(value map[string]interface{}) {
	m.conversation_context = &value
}

// ConversationContext returns the value of the "conversation_context" field in the mutation.
func (m *ChatSessionMutation) ConversationContext() (r map[string]interface{}, exists bool) {
	v := m.conversation_context
	if v == nil {
		return
	}
	return *v, true
}

// OldConversationContext returns the old "conversation_context" field's value of the ChatSession entity.
// If the ChatSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatSessionMutation) OldConversationContext(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversationContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversationContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversationContext: %w", err)
	}
	return oldValue.ConversationContext, nil
}

// ClearConversationContext clears the value of the "conversation_context" field.
func (m *ChatSessionMutation) ClearConversationContext() {
	m.conversation_context = nil
	m.clearedFields[chatsession.FieldConversationContext] = struct{}{}
}

// ConversationContextCleared returns if the "conversation_context" field was cleared in this mutation.
func (m *ChatSessionMutation) ConversationContextCleared() bool {
	_, ok := m.clearedFields[chatsession.FieldConversationContext]
	return ok
}

// ResetConversationContext resets all changes to the "conversation_context" field.
func (m *ChatSessionMutation) ResetConversationContext() {
	m.conversation_context = nil
	delete(m.clearedFields, chatsession.FieldConversationContext)
}

// SetCreatedAt sets the "created_at" field.
func (m *ChatSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChatSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChatSession entity.
// If the ChatSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChatSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChatSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChatSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChatSession entity.
// If the ChatSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChatSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *ChatSessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ChatSessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the ChatSession entity.
// If the ChatSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatSessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ChatSessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ChatSessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[chatsession.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ChatSessionMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ChatSessionMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ChatSessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *ChatSessionMutation) AddMessageIDs(ids ...uuid.UUID) {
	if m.messages == nil {
		m.messages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *ChatSessionMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *ChatSessionMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *ChatSessionMutation) RemoveMessageIDs(ids ...uuid.UUID) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *ChatSessionMutation) RemovedMessagesIDs() (ids []uuid.UUID) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *ChatSessionMutation) MessagesIDs() (ids []uuid.UUID) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *ChatSessionMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// Where appends a list predicates to the ChatSessionMutation builder.
func (m *ChatSessionMutation) Where(ps ...predicate.ChatSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChatSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChatSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChatSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChatSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChatSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChatSession).
func (m *ChatSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChatSessionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.session_id != nil {
		fields = append(fields, chatsession.FieldSessionID)
	}
	if m.user != nil {
		fields = append(fields, chatsession.FieldUserID)
	}
	if m.country_code != nil {
		fields = append(fields, chatsession.FieldCountryCode)
	}
	if m.language_code != nil {
		fields = append(fields, chatsession.FieldLanguageCode)
	}
	if m.currency != nil {
		fields = append(fields, chatsession.FieldCurrency)
	}
	if m.message_count != nil {
		fields = append(fields, chatsession.FieldMessageCount)
	}
	if m.search_state != nil {
		fields = append(fields, chatsession.FieldSearchState)
	}
	if m.cycle_state != nil {
		fields = append(fields, chatsession.FieldCycleState)
	}
	if m.conversation_context != nil {
		fields = append(fields, chatsession.FieldConversationContext)
	}
	if m.created_at != nil {
		fields = append(fields, chatsession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, chatsession.FieldUpdatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, chatsession.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChatSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chatsession.FieldSessionID:
		return m.SessionID()
	case chatsession.FieldUserID:
		return m.UserID()
	case chatsession.FieldCountryCode:
		return m.CountryCode()
	case chatsession.FieldLanguageCode:
		return m.LanguageCode()
	case chatsession.FieldCurrency:
		return m.Currency()
	case chatsession.FieldMessageCount:
		return m.MessageCount()
	case chatsession.FieldSearchState:
		return m.SearchState()
	case chatsession.FieldCycleState:
		return m.CycleState()
	case chatsession.FieldConversationContext:
		return m.ConversationContext()
	case chatsession.FieldCreatedAt:
		return m.CreatedAt()
	case chatsession.FieldUpdatedAt:
		return m.UpdatedAt()
	case chatsession.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChatSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chatsession.FieldSessionID:
		return m.OldSessionID(ctx)
	case chatsession.FieldUserID:
		return m.OldUserID(ctx)
	case chatsession.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case chatsession.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case chatsession.FieldCurrency:
		return m.OldCurrency(ctx)
	case chatsession.FieldMessageCount:
		return m.OldMessageCount(ctx)
	case chatsession.FieldSearchState:
		return m.OldSearchState(ctx)
	case chatsession.FieldCycleState:
		return m.OldCycleState(ctx)
	case chatsession.FieldConversationContext:
		return m.OldConversationContext(ctx)
	case chatsession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case chatsession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case chatsession.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown ChatSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chatsession.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case chatsession.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case chatsession.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case chatsession.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case chatsession.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case chatsession.FieldMessageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageCount(v)
		return nil
	case chatsession.FieldSearchState:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchState(v)
		return nil
	case chatsession.FieldCycleState:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCycleState(v)
		return nil
	case chatsession.FieldConversationContext:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversationContext(v)
		return nil
	case chatsession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case chatsession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case chatsession.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown ChatSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChatSessionMutation) AddedFields() []string {
	var fields []string
	if m.addmessage_count != nil {
		fields = append(fields, chatsession.FieldMessageCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChatSessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case chatsession.FieldMessageCount:
		return m.AddedMessageCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case chatsession.FieldMessageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMessageCount(v)
		return nil
	}
	return fmt.Errorf("unknown ChatSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChatSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(chatsession.FieldUserID) {
		fields = append(fields, chatsession.FieldUserID)
	}
	if m.FieldCleared(chatsession.FieldConversationContext) {
		fields = append(fields, chatsession.FieldConversationContext)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChatSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChatSessionMutation) ClearField(name string) error {
	switch name {
	case chatsession.FieldUserID:
		m.ClearUserID()
		return nil
	case chatsession.FieldConversationContext:
		m.ClearConversationContext()
		return nil
	}
	return fmt.Errorf("unknown ChatSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChatSessionMutation) ResetField(name string) error {
	switch name {
	case chatsession.FieldSessionID:
		m.ResetSessionID()
		return nil
	case chatsession.FieldUserID:
		m.ResetUserID()
		return nil
	case chatsession.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case chatsession.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case chatsession.FieldCurrency:
		m.ResetCurrency()
		return nil
	case chatsession.FieldMessageCount:
		m.ResetMessageCount()
		return nil
	case chatsession.FieldSearchState:
		m.ResetSearchState()
		return nil
	case chatsession.FieldCycleState:
		m.ResetCycleState()
		return nil
	case chatsession.FieldConversationContext:
		m.ResetConversationContext()
		return nil
	case chatsession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case chatsession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case chatsession.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown ChatSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChatSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, chatsession.EdgeUser)
	}
	if m.messages != nil {
		edges = append(edges, chatsession.EdgeMessages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChatSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chatsession.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case chatsession.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChatSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmessages != nil {
		edges = append(edges, chatsession.EdgeMessages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChatSessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case chatsession.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChatSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, chatsession.EdgeUser)
	}
	if m.clearedmessages {
		edges = append(edges, chatsession.EdgeMessages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChatSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case chatsession.EdgeUser:
		return m.cleareduser
	case chatsession.EdgeMessages:
		return m.clearedmessages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChatSessionMutation) ClearEdge(name string) error {
	switch name {
	case chatsession.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ChatSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChatSessionMutation) ResetEdge(name string) error {
	switch name {
	case chatsession.EdgeUser:
		m.ResetUser()
		return nil
	case chatsession.EdgeMessages:
		m.ResetMessages()
		return nil
	}
	return fmt.Errorf("unknown ChatSession edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	role                *string
	content             *string
	response_type       *string
	quick_replies       *[]string
	appendquick_replies []string
	products            *[]map[string]interface{}
	appendproducts      []map[string]interface{}
	search_info         *map[string]interface{}
	created_at          *time.Time
	clearedFields       map[string]struct{}
	session             *uuid.UUID
	clearedsession      bool
	done                bool
	oldValue            func(context.Context) (*Message, error)
	predicates          []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id uuid.UUID) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Message entities.
func (m *MessageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSessionID sets the "session_id" field.
func (m *MessageMutation) SetSessionID(u uuid.UUID) {
	m.session = &u
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *MessageMutation) SessionID() (r uuid.UUID, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSessionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *MessageMutation) ResetSessionID() {
	m.session = nil
}

// SetRole sets the "role" field.
func (m *MessageMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *MessageMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *MessageMutation) ResetRole() {
	m.role = nil
}

// SetContent sets the "content" field.
func (m *MessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *MessageMutation) ResetContent() {
	m.content = nil
}

// SetResponseType sets the "response_type" field.
func (m *MessageMutation) SetResponseType(s string) {
	m.response_type = &s
}

// ResponseType returns the value of the "response_type" field in the mutation.
func (m *MessageMutation) ResponseType() (r string, exists bool) {
	v := m.response_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseType returns the old "response_type" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldResponseType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseType: %w", err)
	}
	return oldValue.ResponseType, nil
}

// ClearResponseType clears the value of the "response_type" field.
func (m *MessageMutation) ClearResponseType() {
	m.response_type = nil
	m.clearedFields[message.FieldResponseType] = struct{}{}
}

// ResponseTypeCleared returns if the "response_type" field was cleared in this mutation.
func (m *MessageMutation) ResponseTypeCleared() bool {
	_, ok := m.clearedFields[message.FieldResponseType]
	return ok
}

// ResetResponseType resets all changes to the "response_type" field.
func (m *MessageMutation) ResetResponseType() {
	m.response_type = nil
	delete(m.clearedFields, message.FieldResponseType)
}

// SetQuickReplies sets the "quick_replies" field.
func (m *MessageMutation) SetQuickReplies(s []string) {
	m.quick_replies = &s
	m.appendquick_replies = nil
}

// QuickReplies returns the value of the "quick_replies" field in the mutation.
func (m *MessageMutation) QuickReplies() (r []string, exists bool) {
	v := m.quick_replies
	if v == nil {
		return
	}
	return *v, true
}

// OldQuickReplies returns the old "quick_replies" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldQuickReplies(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuickReplies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuickReplies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuickReplies: %w", err)
	}
	return oldValue.QuickReplies, nil
}

// AppendQuickReplies adds s to the "quick_replies" field.
func (m *MessageMutation) AppendQuickReplies(s []string) {
	m.appendquick_replies = append(m.appendquick_replies, s...)
}

// AppendedQuickReplies returns the list of values that were appended to the "quick_replies" field in this mutation.
func (m *MessageMutation) AppendedQuickReplies() ([]string, bool) {
	if len(m.appendquick_replies) == 0 {
		return nil, false
	}
	return m.appendquick_replies, true
}

// ClearQuickReplies clears the value of the "quick_replies" field.
func (m *MessageMutation) ClearQuickReplies() {
	m.quick_replies = nil
	m.appendquick_replies = nil
	m.clearedFields[message.FieldQuickReplies] = struct{}{}
}

// QuickRepliesCleared returns if the "quick_replies" field was cleared in this mutation.
func (m *MessageMutation) QuickRepliesCleared() bool {
	_, ok := m.clearedFields[message.FieldQuickReplies]
	return ok
}

// ResetQuickReplies resets all changes to the "quick_replies" field.
func (m *MessageMutation) ResetQuickReplies() {
	m.quick_replies = nil
	m.appendquick_replies = nil
	delete(m.clearedFields, message.FieldQuickReplies)
}

// SetProducts sets the "products" field.
func (m *MessageMutation) SetProducts(value []map[string]interface{}) {
	m.products = &value
	m.appendproducts = nil
}

// Products returns the value of the "products" field in the mutation.
func (m *MessageMutation) Products() (r []map[string]interface{}, exists bool) {
	v := m.products
	if v == nil {
		return
	}
	return *v, true
}

// OldProducts returns the old "products" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldProducts(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProducts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProducts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProducts: %w", err)
	}
	return oldValue.Products, nil
}

// AppendProducts adds value to the "products" field.
func (m *MessageMutation) AppendProducts(value []map[string]interface{}) {
	m.appendproducts = append(m.appendproducts, value...)
}

// AppendedProducts returns the list of values that were appended to the "products" field in this mutation.
func (m *MessageMutation) AppendedProducts() ([]map[string]interface{}, bool) {
	if len(m.appendproducts) == 0 {
		return nil, false
	}
	return m.appendproducts, true
}

// ClearProducts clears the value of the "products" field.
func (m *MessageMutation) ClearProducts() {
	m.products = nil
	m.appendproducts = nil
	m.clearedFields[message.FieldProducts] = struct{}{}
}

// ProductsCleared returns if the "products" field was cleared in this mutation.
func (m *MessageMutation) ProductsCleared() bool {
	_, ok := m.clearedFields[message.FieldProducts]
	return ok
}

// ResetProducts resets all changes to the "products" field.
func (m *MessageMutation) ResetProducts() {
	m.products = nil
	m.appendproducts = nil
	delete(m.clearedFields, message.FieldProducts)
}

// SetSearchInfo sets the "search_info" field.
func (m *MessageMutation) SetSearchInfo(value map[string]interface{}) {
	m.search_info = &value
}

// SearchInfo returns the value of the "search_info" field in the mutation.
func (m *MessageMutation) SearchInfo() (r map[string]interface{}, exists bool) {
	v := m.search_info
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchInfo returns the old "search_info" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSearchInfo(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchInfo: %w", err)
	}
	return oldValue.SearchInfo, nil
}

// ClearSearchInfo clears the value of the "search_info" field.
func (m *MessageMutation) ClearSearchInfo() {
	m.search_info = nil
	m.clearedFields[message.FieldSearchInfo] = struct{}{}
}

// SearchInfoCleared returns if the "search_info" field was cleared in this mutation.
func (m *MessageMutation) SearchInfoCleared() bool {
	_, ok := m.clearedFields[message.FieldSearchInfo]
	return ok
}

// ResetSearchInfo resets all changes to the "search_info" field.
func (m *MessageMutation) ResetSearchInfo() {
	m.search_info = nil
	delete(m.clearedFields, message.FieldSearchInfo)
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearSession clears the "session" edge to the ChatSession entity.
func (m *MessageMutation) ClearSession() {
	m.clearedsession = true
	m.clearedFields[message.FieldSessionID] = struct{}{}
}

// SessionCleared reports if the "session" edge to the ChatSession entity was cleared.
func (m *MessageMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) SessionIDs() (ids []uuid.UUID) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *MessageMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.session != nil {
		fields = append(fields, message.FieldSessionID)
	}
	if m.role != nil {
		fields = append(fields, message.FieldRole)
	}
	if m.content != nil {
		fields = append(fields, message.FieldContent)
	}
	if m.response_type != nil {
		fields = append(fields, message.FieldResponseType)
	}
	if m.quick_replies != nil {
		fields = append(fields, message.FieldQuickReplies)
	}
	if m.products != nil {
		fields = append(fields, message.FieldProducts)
	}
	if m.search_info != nil {
		fields = append(fields, message.FieldSearchInfo)
	}
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldSessionID:
		return m.SessionID()
	case message.FieldRole:
		return m.Role()
	case message.FieldContent:
		return m.Content()
	case message.FieldResponseType:
		return m.ResponseType()
	case message.FieldQuickReplies:
		return m.QuickReplies()
	case message.FieldProducts:
		return m.Products()
	case message.FieldSearchInfo:
		return m.SearchInfo()
	case message.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldSessionID:
		return m.OldSessionID(ctx)
	case message.FieldRole:
		return m.OldRole(ctx)
	case message.FieldContent:
		return m.OldContent(ctx)
	case message.FieldResponseType:
		return m.OldResponseType(ctx)
	case message.FieldQuickReplies:
		return m.OldQuickReplies(ctx)
	case message.FieldProducts:
		return m.OldProducts(ctx)
	case message.FieldSearchInfo:
		return m.OldSearchInfo(ctx)
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldSessionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case message.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case message.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case message.FieldResponseType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseType(v)
		return nil
	case message.FieldQuickReplies:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuickReplies(v)
		return nil
	case message.FieldProducts:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProducts(v)
		return nil
	case message.FieldSearchInfo:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchInfo(v)
		return nil
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldResponseType) {
		fields = append(fields, message.FieldResponseType)
	}
	if m.FieldCleared(message.FieldQuickReplies) {
		fields = append(fields, message.FieldQuickReplies)
	}
	if m.FieldCleared(message.FieldProducts) {
		fields = append(fields, message.FieldProducts)
	}
	if m.FieldCleared(message.FieldSearchInfo) {
		fields = append(fields, message.FieldSearchInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldResponseType:
		m.ClearResponseType()
		return nil
	case message.FieldQuickReplies:
		m.ClearQuickReplies()
		return nil
	case message.FieldProducts:
		m.ClearProducts()
		return nil
	case message.FieldSearchInfo:
		m.ClearSearchInfo()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldSessionID:
		m.ResetSessionID()
		return nil
	case message.FieldRole:
		m.ResetRole()
		return nil
	case message.FieldContent:
		m.ResetContent()
		return nil
	case message.FieldResponseType:
		m.ResetResponseType()
		return nil
	case message.FieldQuickReplies:
		m.ResetQuickReplies()
		return nil
	case message.FieldProducts:
		m.ResetProducts()
		return nil
	case message.FieldSearchInfo:
		m.ResetSearchInfo()
		return nil
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.session != nil {
		edges = append(edges, message.EdgeSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsession {
		edges = append(edges, message.EdgeSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeSession:
		return m.clearedsession
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeSession:
		m.ResetSession()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// SearchHistoryMutation represents an operation that mutates the SearchHistory nodes in the graph.
type SearchHistoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	session_id           *string
	search_query         *string
	optimized_query      *string
	search_type          *string
	category             *string
	country_code         *string
	language_code        *string
	currency             *string
	result_count         *int
	addresult_count      *int
	products_found       *[]map[string]interface{}
	appendproducts_found []map[string]interface{}
	clicked_product_id   *string
	created_at           *time.Time
	expires_at           *time.Time
	clearedFields        map[string]struct{}
	user                 *uuid.UUID
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*SearchHistory, error)
	predicates           []predicate.SearchHistory
}

var _ ent.Mutation = (*SearchHistoryMutation)(nil)

// searchhistoryOption allows management of the mutation configuration using functional options.
type searchhistoryOption func(*SearchHistoryMutation)

// newSearchHistoryMutation creates new mutation for the SearchHistory entity.
func newSearchHistoryMutation(c config, op Op, opts ...searchhistoryOption) *SearchHistoryMutation {
	m := &SearchHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeSearchHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSearchHistoryID sets the ID field of the mutation.
func withSearchHistoryID(id uuid.UUID) searchhistoryOption {
	return func(m *SearchHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *SearchHistory
		)
		m.oldValue = func(ctx context.Context) (*SearchHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SearchHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSearchHistory sets the old SearchHistory of the mutation.
func withSearchHistory(node *SearchHistory) searchhistoryOption {
	return func(m *SearchHistoryMutation) {
		m.oldValue = func(context.Context) (*SearchHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SearchHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SearchHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SearchHistory entities.
func (m *SearchHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SearchHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SearchHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SearchHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SearchHistoryMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SearchHistoryMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SearchHistory entity.
// If the SearchHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchHistoryMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *SearchHistoryMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[searchhistory.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *SearchHistoryMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[searchhistory.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SearchHistoryMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, searchhistory.FieldUserID)
}

// SetSessionID sets the "session_id" field.
func (m *SearchHistoryMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *SearchHistoryMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the SearchHistory entity.
// If the SearchHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchHistoryMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ClearSessionID clears the value of the "session_id" field.
func (m *SearchHistoryMutation) ClearSessionID() {
	m.session_id = nil
	m.clearedFields[searchhistory.FieldSessionID] = struct{}{}
}

// SessionIDCleared returns if the "session_id" field was cleared in this mutation.
func (m *SearchHistoryMutation) SessionIDCleared() bool {
	_, ok := m.clearedFields[searchhistory.FieldSessionID]
	return ok
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *SearchHistoryMutation) ResetSessionID() {
	m.session_id = nil
	delete(m.clearedFields, searchhistory.FieldSessionID)
}

// SetSearchQuery sets the "search_query" field.
func (m *SearchHistoryMutation) SetSearchQuery(s string) {
	m.search_query = &s
}

// SearchQuery returns the value of the "search_query" field in the mutation.
func (m *SearchHistoryMutation) SearchQuery() (r string, exists bool) {
	v := m.search_query
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchQuery returns the old "search_query" field's value of the SearchHistory entity.
// If the SearchHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchHistoryMutation) OldSearchQuery(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchQuery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchQuery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchQuery: %w", err)
	}
	return oldValue.SearchQuery, nil
}

// ResetSearchQuery resets all changes to the "search_query" field.
func (m *SearchHistoryMutation) ResetSearchQuery() {
	m.search_query = nil
}

// SetOptimizedQuery sets the "optimized_query" field.
func (m *SearchHistoryMutation) SetOptimizedQuery(s string) {
	m.optimized_query = &s
}

// OptimizedQuery returns the value of the "optimized_query" field in the mutation.
func (m *SearchHistoryMutation) OptimizedQuery() (r string, exists bool) {
	v := m.optimized_query
	if v == nil {
		return
	}
	return *v, true
}

// OldOptimizedQuery returns the old "optimized_query" field's value of the SearchHistory entity.
// If the SearchHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchHistoryMutation) OldOptimizedQuery(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptimizedQuery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptimizedQuery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptimizedQuery: %w", err)
	}
	return oldValue.OptimizedQuery, nil
}

// ClearOptimizedQuery clears the value of the "optimized_query" field.
func (m *SearchHistoryMutation) ClearOptimizedQuery() {
	m.optimized_query = nil
	m.clearedFields[searchhistory.FieldOptimizedQuery] = struct{}{}
}

// OptimizedQueryCleared returns if the "optimized_query" field was cleared in this mutation.
func (m *SearchHistoryMutation) OptimizedQueryCleared() bool {
	_, ok := m.clearedFields[searchhistory.FieldOptimizedQuery]
	return ok
}

// ResetOptimizedQuery resets all changes to the "optimized_query" field.
func (m *SearchHistoryMutation) ResetOptimizedQuery() {
	m.optimized_query = nil
	delete(m.clearedFields, searchhistory.FieldOptimizedQuery)
}

// SetSearchType sets the "search_type" field.
func (m *SearchHistoryMutation) SetSearchType(s string) {
	m.search_type = &s
}

// SearchType returns the value of the "search_type" field in the mutation.
func (m *SearchHistoryMutation) SearchType() (r string, exists bool) {
	v := m.search_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchType returns the old "search_type" field's value of the SearchHistory entity.
// If the SearchHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchHistoryMutation) OldSearchType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchType: %w", err)
	}
	return oldValue.SearchType, nil
}

// ResetSearchType resets all changes to the "search_type" field.
func (m *SearchHistoryMutation) ResetSearchType() {
	m.search_type = nil
}

// SetCategory sets the "category" field.
func (m *SearchHistoryMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *SearchHistoryMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the SearchHistory entity.
// If the SearchHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchHistoryMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *SearchHistoryMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[searchhistory.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *SearchHistoryMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[searchhistory.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *SearchHistoryMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, searchhistory.FieldCategory)
}

// SetCountryCode sets the "country_code" field.
func (m *SearchHistoryMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *SearchHistoryMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the SearchHistory entity.
// If the SearchHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchHistoryMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *SearchHistoryMutation) ResetCountryCode() {
	m.country_code = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *SearchHistoryMutation) SetLanguageCode(s string) {
	m.language_code = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *SearchHistoryMutation) LanguageCode() (r string, exists bool) {
	v := m.language_code
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the SearchHistory entity.
// If the SearchHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchHistoryMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *SearchHistoryMutation) ResetLanguageCode() {
	m.language_code = nil
}

// SetCurrency sets the "currency" field.
func (m *SearchHistoryMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *SearchHistoryMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the SearchHistory entity.
// If the SearchHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchHistoryMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *SearchHistoryMutation) ResetCurrency() {
	m.currency = nil
}

// SetResultCount sets the "result_count" field.
func (m *SearchHistoryMutation) SetResultCount(i int) {
	m.result_count = &i
	m.addresult_count = nil
}

// ResultCount returns the value of the "result_count" field in the mutation.
func (m *SearchHistoryMutation) ResultCount() (r int, exists bool) {
	v := m.result_count
	if v == nil {
		return
	}
	return *v, true
}

// OldResultCount returns the old "result_count" field's value of the SearchHistory entity.
// If the SearchHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchHistoryMutation) OldResultCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultCount: %w", err)
	}
	return oldValue.ResultCount, nil
}

// AddResultCount adds i to the "result_count" field.
func (m *SearchHistoryMutation) AddResultCount(i int) {
	if m.addresult_count != nil {
		*m.addresult_count += i
	} else {
		m.addresult_count = &i
	}
}

// AddedResultCount returns the value that was added to the "result_count" field in this mutation.
func (m *SearchHistoryMutation) AddedResultCount() (r int, exists bool) {
	v := m.addresult_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetResultCount resets all changes to the "result_count" field.
func (m *SearchHistoryMutation) ResetResultCount() {
	m.result_count = nil
	m.addresult_count = nil
}

// SetProductsFound sets the "products_found" field.
func (m *SearchHistoryMutation) SetProductsFound(value []map[string]interface{}) {
	m.products_found = &value
	m.appendproducts_found = nil
}

// ProductsFound returns the value of the "products_found" field in the mutation.
func (m *SearchHistoryMutation) ProductsFound() (r []map[string]interface{}, exists bool) {
	v := m.products_found
	if v == nil {
		return
	}
	return *v, true
}

// OldProductsFound returns the old "products_found" field's value of the SearchHistory entity.
// If the SearchHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchHistoryMutation) OldProductsFound(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductsFound is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductsFound requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductsFound: %w", err)
	}
	return oldValue.ProductsFound, nil
}

// AppendProductsFound adds value to the "products_found" field.
func (m *SearchHistoryMutation) AppendProductsFound(value []map[string]interface{}) {
	m.appendproducts_found = append(m.appendproducts_found, value...)
}

// AppendedProductsFound returns the list of values that were appended to the "products_found" field in this mutation.
func (m *SearchHistoryMutation) AppendedProductsFound() ([]map[string]interface{}, bool) {
	if len(m.appendproducts_found) == 0 {
		return nil, false
	}
	return m.appendproducts_found, true
}

// ClearProductsFound clears the value of the "products_found" field.
func (m *SearchHistoryMutation) ClearProductsFound() {
	m.products_found = nil
	m.appendproducts_found = nil
	m.clearedFields[searchhistory.FieldProductsFound] = struct{}{}
}

// ProductsFoundCleared returns if the "products_found" field was cleared in this mutation.
func (m *SearchHistoryMutation) ProductsFoundCleared() bool {
	_, ok := m.clearedFields[searchhistory.FieldProductsFound]
	return ok
}

// ResetProductsFound resets all changes to the "products_found" field.
func (m *SearchHistoryMutation) ResetProductsFound() {
	m.products_found = nil
	m.appendproducts_found = nil
	delete(m.clearedFields, searchhistory.FieldProductsFound)
}

// SetClickedProductID sets the "clicked_product_id" field.
func (m *SearchHistoryMutation) SetClickedProductID(s string) {
	m.clicked_product_id = &s
}

// ClickedProductID returns the value of the "clicked_product_id" field in the mutation.
func (m *SearchHistoryMutation) ClickedProductID() (r string, exists bool) {
	v := m.clicked_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClickedProductID returns the old "clicked_product_id" field's value of the SearchHistory entity.
// If the SearchHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchHistoryMutation) OldClickedProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClickedProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClickedProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClickedProductID: %w", err)
	}
	return oldValue.ClickedProductID, nil
}

// ClearClickedProductID clears the value of the "clicked_product_id" field.
func (m *SearchHistoryMutation) ClearClickedProductID() {
	m.clicked_product_id = nil
	m.clearedFields[searchhistory.FieldClickedProductID] = struct{}{}
}

// ClickedProductIDCleared returns if the "clicked_product_id" field was cleared in this mutation.
func (m *SearchHistoryMutation) ClickedProductIDCleared() bool {
	_, ok := m.clearedFields[searchhistory.FieldClickedProductID]
	return ok
}

// ResetClickedProductID resets all changes to the "clicked_product_id" field.
func (m *SearchHistoryMutation) ResetClickedProductID() {
	m.clicked_product_id = nil
	delete(m.clearedFields, searchhistory.FieldClickedProductID)
}

// SetCreatedAt sets the "created_at" field.
func (m *SearchHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SearchHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SearchHistory entity.
// If the SearchHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SearchHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *SearchHistoryMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SearchHistoryMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the SearchHistory entity.
// If the SearchHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SearchHistoryMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *SearchHistoryMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[searchhistory.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *SearchHistoryMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[searchhistory.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SearchHistoryMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, searchhistory.FieldExpiresAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *SearchHistoryMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[searchhistory.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SearchHistoryMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SearchHistoryMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SearchHistoryMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SearchHistoryMutation builder.
func (m *SearchHistoryMutation) Where(ps ...predicate.SearchHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SearchHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SearchHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SearchHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SearchHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SearchHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SearchHistory).
func (m *SearchHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SearchHistoryMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.user != nil {
		fields = append(fields, searchhistory.FieldUserID)
	}
	if m.session_id != nil {
		fields = append(fields, searchhistory.FieldSessionID)
	}
	if m.search_query != nil {
		fields = append(fields, searchhistory.FieldSearchQuery)
	}
	if m.optimized_query != nil {
		fields = append(fields, searchhistory.FieldOptimizedQuery)
	}
	if m.search_type != nil {
		fields = append(fields, searchhistory.FieldSearchType)
	}
	if m.category != nil {
		fields = append(fields, searchhistory.FieldCategory)
	}
	if m.country_code != nil {
		fields = append(fields, searchhistory.FieldCountryCode)
	}
	if m.language_code != nil {
		fields = append(fields, searchhistory.FieldLanguageCode)
	}
	if m.currency != nil {
		fields = append(fields, searchhistory.FieldCurrency)
	}
	if m.result_count != nil {
		fields = append(fields, searchhistory.FieldResultCount)
	}
	if m.products_found != nil {
		fields = append(fields, searchhistory.FieldProductsFound)
	}
	if m.clicked_product_id != nil {
		fields = append(fields, searchhistory.FieldClickedProductID)
	}
	if m.created_at != nil {
		fields = append(fields, searchhistory.FieldCreatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, searchhistory.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SearchHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case searchhistory.FieldUserID:
		return m.UserID()
	case searchhistory.FieldSessionID:
		return m.SessionID()
	case searchhistory.FieldSearchQuery:
		return m.SearchQuery()
	case searchhistory.FieldOptimizedQuery:
		return m.OptimizedQuery()
	case searchhistory.FieldSearchType:
		return m.SearchType()
	case searchhistory.FieldCategory:
		return m.Category()
	case searchhistory.FieldCountryCode:
		return m.CountryCode()
	case searchhistory.FieldLanguageCode:
		return m.LanguageCode()
	case searchhistory.FieldCurrency:
		return m.Currency()
	case searchhistory.FieldResultCount:
		return m.ResultCount()
	case searchhistory.FieldProductsFound:
		return m.ProductsFound()
	case searchhistory.FieldClickedProductID:
		return m.ClickedProductID()
	case searchhistory.FieldCreatedAt:
		return m.CreatedAt()
	case searchhistory.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SearchHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case searchhistory.FieldUserID:
		return m.OldUserID(ctx)
	case searchhistory.FieldSessionID:
		return m.OldSessionID(ctx)
	case searchhistory.FieldSearchQuery:
		return m.OldSearchQuery(ctx)
	case searchhistory.FieldOptimizedQuery:
		return m.OldOptimizedQuery(ctx)
	case searchhistory.FieldSearchType:
		return m.OldSearchType(ctx)
	case searchhistory.FieldCategory:
		return m.OldCategory(ctx)
	case searchhistory.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case searchhistory.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case searchhistory.FieldCurrency:
		return m.OldCurrency(ctx)
	case searchhistory.FieldResultCount:
		return m.OldResultCount(ctx)
	case searchhistory.FieldProductsFound:
		return m.OldProductsFound(ctx)
	case searchhistory.FieldClickedProductID:
		return m.OldClickedProductID(ctx)
	case searchhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case searchhistory.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown SearchHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SearchHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case searchhistory.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case searchhistory.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case searchhistory.FieldSearchQuery:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchQuery(v)
		return nil
	case searchhistory.FieldOptimizedQuery:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptimizedQuery(v)
		return nil
	case searchhistory.FieldSearchType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchType(v)
		return nil
	case searchhistory.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case searchhistory.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case searchhistory.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case searchhistory.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case searchhistory.FieldResultCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultCount(v)
		return nil
	case searchhistory.FieldProductsFound:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductsFound(v)
		return nil
	case searchhistory.FieldClickedProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClickedProductID(v)
		return nil
	case searchhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case searchhistory.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown SearchHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SearchHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addresult_count != nil {
		fields = append(fields, searchhistory.FieldResultCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SearchHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case searchhistory.FieldResultCount:
		return m.AddedResultCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SearchHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case searchhistory.FieldResultCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResultCount(v)
		return nil
	}
	return fmt.Errorf("unknown SearchHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SearchHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(searchhistory.FieldUserID) {
		fields = append(fields, searchhistory.FieldUserID)
	}
	if m.FieldCleared(searchhistory.FieldSessionID) {
		fields = append(fields, searchhistory.FieldSessionID)
	}
	if m.FieldCleared(searchhistory.FieldOptimizedQuery) {
		fields = append(fields, searchhistory.FieldOptimizedQuery)
	}
	if m.FieldCleared(searchhistory.FieldCategory) {
		fields = append(fields, searchhistory.FieldCategory)
	}
	if m.FieldCleared(searchhistory.FieldProductsFound) {
		fields = append(fields, searchhistory.FieldProductsFound)
	}
	if m.FieldCleared(searchhistory.FieldClickedProductID) {
		fields = append(fields, searchhistory.FieldClickedProductID)
	}
	if m.FieldCleared(searchhistory.FieldExpiresAt) {
		fields = append(fields, searchhistory.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SearchHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SearchHistoryMutation) ClearField(name string) error {
	switch name {
	case searchhistory.FieldUserID:
		m.ClearUserID()
		return nil
	case searchhistory.FieldSessionID:
		m.ClearSessionID()
		return nil
	case searchhistory.FieldOptimizedQuery:
		m.ClearOptimizedQuery()
		return nil
	case searchhistory.FieldCategory:
		m.ClearCategory()
		return nil
	case searchhistory.FieldProductsFound:
		m.ClearProductsFound()
		return nil
	case searchhistory.FieldClickedProductID:
		m.ClearClickedProductID()
		return nil
	case searchhistory.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown SearchHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SearchHistoryMutation) ResetField(name string) error {
	switch name {
	case searchhistory.FieldUserID:
		m.ResetUserID()
		return nil
	case searchhistory.FieldSessionID:
		m.ResetSessionID()
		return nil
	case searchhistory.FieldSearchQuery:
		m.ResetSearchQuery()
		return nil
	case searchhistory.FieldOptimizedQuery:
		m.ResetOptimizedQuery()
		return nil
	case searchhistory.FieldSearchType:
		m.ResetSearchType()
		return nil
	case searchhistory.FieldCategory:
		m.ResetCategory()
		return nil
	case searchhistory.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case searchhistory.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case searchhistory.FieldCurrency:
		m.ResetCurrency()
		return nil
	case searchhistory.FieldResultCount:
		m.ResetResultCount()
		return nil
	case searchhistory.FieldProductsFound:
		m.ResetProductsFound()
		return nil
	case searchhistory.FieldClickedProductID:
		m.ResetClickedProductID()
		return nil
	case searchhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case searchhistory.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown SearchHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SearchHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, searchhistory.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SearchHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case searchhistory.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SearchHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SearchHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SearchHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, searchhistory.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SearchHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case searchhistory.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SearchHistoryMutation) ClearEdge(name string) error {
	switch name {
	case searchhistory.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown SearchHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SearchHistoryMutation) ResetEdge(name string) error {
	switch name {
	case searchhistory.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown SearchHistory edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	email                 *string
	password_hash         *string
	google_id             *string
	name                  *string
	avatar_url            *string
	provider              *string
	created_at            *time.Time
	updated_at            *time.Time
	last_login            *time.Time
	clearedFields         map[string]struct{}
	sessions              map[uuid.UUID]struct{}
	removedsessions       map[uuid.UUID]struct{}
	clearedsessions       bool
	search_history        map[uuid.UUID]struct{}
	removedsearch_history map[uuid.UUID]struct{}
	clearedsearch_history bool
	preferences           *uuid.UUID
	clearedpreferences    bool
	done                  bool
	oldValue              func(context.Context) (*User, error)
	predicates            []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ClearPasswordHash clears the value of the "password_hash" field.
func (m *UserMutation) ClearPasswordHash() {
	m.password_hash = nil
	m.clearedFields[user.FieldPasswordHash] = struct{}{}
}

// PasswordHashCleared returns if the "password_hash" field was cleared in this mutation.
func (m *UserMutation) PasswordHashCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordHash]
	return ok
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
	delete(m.clearedFields, user.FieldPasswordHash)
}

// SetGoogleID sets the "google_id" field.
func (m *UserMutation) SetGoogleID(s string) {
	m.google_id = &s
}

// GoogleID returns the value of the "google_id" field in the mutation.
func (m *UserMutation) GoogleID() (r string, exists bool) {
	v := m.google_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoogleID returns the old "google_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGoogleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoogleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoogleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoogleID: %w", err)
	}
	return oldValue.GoogleID, nil
}

// ClearGoogleID clears the value of the "google_id" field.
func (m *UserMutation) ClearGoogleID() {
	m.google_id = nil
	m.clearedFields[user.FieldGoogleID] = struct{}{}
}

// GoogleIDCleared returns if the "google_id" field was cleared in this mutation.
func (m *UserMutation) GoogleIDCleared() bool {
	_, ok := m.clearedFields[user.FieldGoogleID]
	return ok
}

// ResetGoogleID resets all changes to the "google_id" field.
func (m *UserMutation) ResetGoogleID() {
	m.google_id = nil
	delete(m.clearedFields, user.FieldGoogleID)
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetProvider sets the "provider" field.
func (m *UserMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *UserMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *UserMutation) ResetProvider() {
	m.provider = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ClearLastLogin clears the value of the "last_login" field.
func (m *UserMutation) ClearLastLogin() {
	m.last_login = nil
	m.clearedFields[user.FieldLastLogin] = struct{}{}
}

// LastLoginCleared returns if the "last_login" field was cleared in this mutation.
func (m *UserMutation) LastLoginCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLogin]
	return ok
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
	delete(m.clearedFields, user.FieldLastLogin)
}

// AddSessionIDs adds the "sessions" edge to the ChatSession entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...uuid.UUID) {
	if m.sessions == nil {
		m.sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the ChatSession entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the ChatSession entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the ChatSession entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...uuid.UUID) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the ChatSession entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []uuid.UUID) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddSearchHistoryIDs adds the "search_history" edge to the SearchHistory entity by ids.
func (m *UserMutation) AddSearchHistoryIDs(ids ...uuid.UUID) {
	if m.search_history == nil {
		m.search_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.search_history[ids[i]] = struct{}{}
	}
}

// ClearSearchHistory clears the "search_history" edge to the SearchHistory entity.
func (m *UserMutation) ClearSearchHistory() {
	m.clearedsearch_history = true
}

// SearchHistoryCleared reports if the "search_history" edge to the SearchHistory entity was cleared.
func (m *UserMutation) SearchHistoryCleared() bool {
	return m.clearedsearch_history
}

// RemoveSearchHistoryIDs removes the "search_history" edge to the SearchHistory entity by IDs.
func (m *UserMutation) RemoveSearchHistoryIDs(ids ...uuid.UUID) {
	if m.removedsearch_history == nil {
		m.removedsearch_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.search_history, ids[i])
		m.removedsearch_history[ids[i]] = struct{}{}
	}
}

// RemovedSearchHistory returns the removed IDs of the "search_history" edge to the SearchHistory entity.
func (m *UserMutation) RemovedSearchHistoryIDs() (ids []uuid.UUID) {
	for id := range m.removedsearch_history {
		ids = append(ids, id)
	}
	return
}

// SearchHistoryIDs returns the "search_history" edge IDs in the mutation.
func (m *UserMutation) SearchHistoryIDs() (ids []uuid.UUID) {
	for id := range m.search_history {
		ids = append(ids, id)
	}
	return
}

// ResetSearchHistory resets all changes to the "search_history" edge.
func (m *UserMutation) ResetSearchHistory() {
	m.search_history = nil
	m.clearedsearch_history = false
	m.removedsearch_history = nil
}

// SetPreferencesID sets the "preferences" edge to the UserPreference entity by id.
func (m *UserMutation) SetPreferencesID(id uuid.UUID) {
	m.preferences = &id
}

// ClearPreferences clears the "preferences" edge to the UserPreference entity.
func (m *UserMutation) ClearPreferences() {
	m.clearedpreferences = true
}

// PreferencesCleared reports if the "preferences" edge to the UserPreference entity was cleared.
func (m *UserMutation) PreferencesCleared() bool {
	return m.clearedpreferences
}

// PreferencesID returns the "preferences" edge ID in the mutation.
func (m *UserMutation) PreferencesID() (id uuid.UUID, exists bool) {
	if m.preferences != nil {
		return *m.preferences, true
	}
	return
}

// PreferencesIDs returns the "preferences" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PreferencesID instead. It exists only for internal usage by the builders.
func (m *UserMutation) PreferencesIDs() (ids []uuid.UUID) {
	if id := m.preferences; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPreferences resets all changes to the "preferences" edge.
func (m *UserMutation) ResetPreferences() {
	m.preferences = nil
	m.clearedpreferences = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.google_id != nil {
		fields = append(fields, user.FieldGoogleID)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.provider != nil {
		fields = append(fields, user.FieldProvider)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldGoogleID:
		return m.GoogleID()
	case user.FieldName:
		return m.Name()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldProvider:
		return m.Provider()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldLastLogin:
		return m.LastLogin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldGoogleID:
		return m.OldGoogleID(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldProvider:
		return m.OldProvider(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldGoogleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoogleID(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPasswordHash) {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.FieldCleared(user.FieldGoogleID) {
		fields = append(fields, user.FieldGoogleID)
	}
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.FieldCleared(user.FieldLastLogin) {
		fields = append(fields, user.FieldLastLogin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPasswordHash:
		m.ClearPasswordHash()
		return nil
	case user.FieldGoogleID:
		m.ClearGoogleID()
		return nil
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case user.FieldLastLogin:
		m.ClearLastLogin()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldGoogleID:
		m.ResetGoogleID()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldProvider:
		m.ResetProvider()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.search_history != nil {
		edges = append(edges, user.EdgeSearchHistory)
	}
	if m.preferences != nil {
		edges = append(edges, user.EdgePreferences)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSearchHistory:
		ids := make([]ent.Value, 0, len(m.search_history))
		for id := range m.search_history {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePreferences:
		if id := m.preferences; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedsearch_history != nil {
		edges = append(edges, user.EdgeSearchHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSearchHistory:
		ids := make([]ent.Value, 0, len(m.removedsearch_history))
		for id := range m.removedsearch_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedsearch_history {
		edges = append(edges, user.EdgeSearchHistory)
	}
	if m.clearedpreferences {
		edges = append(edges, user.EdgePreferences)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeSearchHistory:
		return m.clearedsearch_history
	case user.EdgePreferences:
		return m.clearedpreferences
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgePreferences:
		m.ClearPreferences()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeSearchHistory:
		m.ResetSearchHistory()
		return nil
	case user.EdgePreferences:
		m.ResetPreferences()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserPreferenceMutation represents an operation that mutates the UserPreference nodes in the graph.
type UserPreferenceMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	country                *string
	currency               *string
	language               *string
	theme                  *string
	sidebar_open           *bool
	last_active_session_id *string
	saved_search           *map[string]interface{}
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	user                   *uuid.UUID
	cleareduser            bool
	done                   bool
	oldValue               func(context.Context) (*UserPreference, error)
	predicates             []predicate.UserPreference
}

var _ ent.Mutation = (*UserPreferenceMutation)(nil)

// userpreferenceOption allows management of the mutation configuration using functional options.
type userpreferenceOption func(*UserPreferenceMutation)

// newUserPreferenceMutation creates new mutation for the UserPreference entity.
func newUserPreferenceMutation(c config, op Op, opts ...userpreferenceOption) *UserPreferenceMutation {
	m := &UserPreferenceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserPreference,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserPreferenceID sets the ID field of the mutation.
func withUserPreferenceID(id uuid.UUID) userpreferenceOption {
	return func(m *UserPreferenceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserPreference
		)
		m.oldValue = func(ctx context.Context) (*UserPreference, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserPreference.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserPreference sets the old UserPreference of the mutation.
func withUserPreference(node *UserPreference) userpreferenceOption {
	return func(m *UserPreferenceMutation) {
		m.oldValue = func(context.Context) (*UserPreference, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserPreferenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserPreferenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserPreference entities.
func (m *UserPreferenceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserPreferenceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserPreferenceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserPreference.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserPreferenceMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserPreferenceMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserPreference entity.
// If the UserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPreferenceMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserPreferenceMutation) ResetUserID() {
	m.user = nil
}

// SetCountry sets the "country" field.
func (m *UserPreferenceMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *UserPreferenceMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the UserPreference entity.
// If the UserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPreferenceMutation) OldCountry(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *UserPreferenceMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[userpreference.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *UserPreferenceMutation) CountryCleared() bool {
	_, ok := m.clearedFields[userpreference.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *UserPreferenceMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, userpreference.FieldCountry)
}

// SetCurrency sets the "currency" field.
func (m *UserPreferenceMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *UserPreferenceMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the UserPreference entity.
// If the UserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPreferenceMutation) OldCurrency(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *UserPreferenceMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[userpreference.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *UserPreferenceMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[userpreference.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *UserPreferenceMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, userpreference.FieldCurrency)
}

// SetLanguage sets the "language" field.
func (m *UserPreferenceMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *UserPreferenceMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the UserPreference entity.
// If the UserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPreferenceMutation) OldLanguage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ClearLanguage clears the value of the "language" field.
func (m *UserPreferenceMutation) ClearLanguage() {
	m.language = nil
	m.clearedFields[userpreference.FieldLanguage] = struct{}{}
}

// LanguageCleared returns if the "language" field was cleared in this mutation.
func (m *UserPreferenceMutation) LanguageCleared() bool {
	_, ok := m.clearedFields[userpreference.FieldLanguage]
	return ok
}

// ResetLanguage resets all changes to the "language" field.
func (m *UserPreferenceMutation) ResetLanguage() {
	m.language = nil
	delete(m.clearedFields, userpreference.FieldLanguage)
}

// SetTheme sets the "theme" field.
func (m *UserPreferenceMutation) SetTheme(s string) {
	m.theme = &s
}

// Theme returns the value of the "theme" field in the mutation.
func (m *UserPreferenceMutation) Theme() (r string, exists bool) {
	v := m.theme
	if v == nil {
		return
	}
	return *v, true
}

// OldTheme returns the old "theme" field's value of the UserPreference entity.
// If the UserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPreferenceMutation) OldTheme(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTheme: %w", err)
	}
	return oldValue.Theme, nil
}

// ClearTheme clears the value of the "theme" field.
func (m *UserPreferenceMutation) ClearTheme() {
	m.theme = nil
	m.clearedFields[userpreference.FieldTheme] = struct{}{}
}

// ThemeCleared returns if the "theme" field was cleared in this mutation.
func (m *UserPreferenceMutation) ThemeCleared() bool {
	_, ok := m.clearedFields[userpreference.FieldTheme]
	return ok
}

// ResetTheme resets all changes to the "theme" field.
func (m *UserPreferenceMutation) ResetTheme() {
	m.theme = nil
	delete(m.clearedFields, userpreference.FieldTheme)
}

// SetSidebarOpen sets the "sidebar_open" field.
func (m *UserPreferenceMutation) SetSidebarOpen(b bool) {
	m.sidebar_open = &b
}

// SidebarOpen returns the value of the "sidebar_open" field in the mutation.
func (m *UserPreferenceMutation) SidebarOpen() (r bool, exists bool) {
	v := m.sidebar_open
	if v == nil {
		return
	}
	return *v, true
}

// OldSidebarOpen returns the old "sidebar_open" field's value of the UserPreference entity.
// If the UserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPreferenceMutation) OldSidebarOpen(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSidebarOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSidebarOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSidebarOpen: %w", err)
	}
	return oldValue.SidebarOpen, nil
}

// ClearSidebarOpen clears the value of the "sidebar_open" field.
func (m *UserPreferenceMutation) ClearSidebarOpen() {
	m.sidebar_open = nil
	m.clearedFields[userpreference.FieldSidebarOpen] = struct{}{}
}

// SidebarOpenCleared returns if the "sidebar_open" field was cleared in this mutation.
func (m *UserPreferenceMutation) SidebarOpenCleared() bool {
	_, ok := m.clearedFields[userpreference.FieldSidebarOpen]
	return ok
}

// ResetSidebarOpen resets all changes to the "sidebar_open" field.
func (m *UserPreferenceMutation) ResetSidebarOpen() {
	m.sidebar_open = nil
	delete(m.clearedFields, userpreference.FieldSidebarOpen)
}

// SetLastActiveSessionID sets the "last_active_session_id" field.
func (m *UserPreferenceMutation) SetLastActiveSessionID(s string) {
	m.last_active_session_id = &s
}

// LastActiveSessionID returns the value of the "last_active_session_id" field in the mutation.
func (m *UserPreferenceMutation) LastActiveSessionID() (r string, exists bool) {
	v := m.last_active_session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLastActiveSessionID returns the old "last_active_session_id" field's value of the UserPreference entity.
// If the UserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPreferenceMutation) OldLastActiveSessionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastActiveSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastActiveSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastActiveSessionID: %w", err)
	}
	return oldValue.LastActiveSessionID, nil
}

// ClearLastActiveSessionID clears the value of the "last_active_session_id" field.
func (m *UserPreferenceMutation) ClearLastActiveSessionID() {
	m.last_active_session_id = nil
	m.clearedFields[userpreference.FieldLastActiveSessionID] = struct{}{}
}

// LastActiveSessionIDCleared returns if the "last_active_session_id" field was cleared in this mutation.
func (m *UserPreferenceMutation) LastActiveSessionIDCleared() bool {
	_, ok := m.clearedFields[userpreference.FieldLastActiveSessionID]
	return ok
}

// ResetLastActiveSessionID resets all changes to the "last_active_session_id" field.
func (m *UserPreferenceMutation) ResetLastActiveSessionID() {
	m.last_active_session_id = nil
	delete(m.clearedFields, userpreference.FieldLastActiveSessionID)
}

// SetSavedSearch sets the "saved_search" field.
func (m *UserPreferenceMutation) SetSavedSearch(value map[string]interface{}) {
	m.saved_search = &value
}

// SavedSearch returns the value of the "saved_search" field in the mutation.
func (m *UserPreferenceMutation) SavedSearch() (r map[string]interface{}, exists bool) {
	v := m.saved_search
	if v == nil {
		return
	}
	return *v, true
}

// OldSavedSearch returns the old "saved_search" field's value of the UserPreference entity.
// If the UserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPreferenceMutation) OldSavedSearch(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSavedSearch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSavedSearch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSavedSearch: %w", err)
	}
	return oldValue.SavedSearch, nil
}

// ClearSavedSearch clears the value of the "saved_search" field.
func (m *UserPreferenceMutation) ClearSavedSearch() {
	m.saved_search = nil
	m.clearedFields[userpreference.FieldSavedSearch] = struct{}{}
}

// SavedSearchCleared returns if the "saved_search" field was cleared in this mutation.
func (m *UserPreferenceMutation) SavedSearchCleared() bool {
	_, ok := m.clearedFields[userpreference.FieldSavedSearch]
	return ok
}

// ResetSavedSearch resets all changes to the "saved_search" field.
func (m *UserPreferenceMutation) ResetSavedSearch() {
	m.saved_search = nil
	delete(m.clearedFields, userpreference.FieldSavedSearch)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserPreferenceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserPreferenceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserPreference entity.
// If the UserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPreferenceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserPreferenceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserPreferenceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserPreferenceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserPreference entity.
// If the UserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPreferenceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserPreferenceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserPreferenceMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userpreference.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserPreferenceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserPreferenceMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserPreferenceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserPreferenceMutation builder.
func (m *UserPreferenceMutation) Where(ps ...predicate.UserPreference) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserPreferenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserPreferenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserPreference, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserPreferenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserPreferenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserPreference).
func (m *UserPreferenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserPreferenceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.user != nil {
		fields = append(fields, userpreference.FieldUserID)
	}
	if m.country != nil {
		fields = append(fields, userpreference.FieldCountry)
	}
	if m.currency != nil {
		fields = append(fields, userpreference.FieldCurrency)
	}
	if m.language != nil {
		fields = append(fields, userpreference.FieldLanguage)
	}
	if m.theme != nil {
		fields = append(fields, userpreference.FieldTheme)
	}
	if m.sidebar_open != nil {
		fields = append(fields, userpreference.FieldSidebarOpen)
	}
	if m.last_active_session_id != nil {
		fields = append(fields, userpreference.FieldLastActiveSessionID)
	}
	if m.saved_search != nil {
		fields = append(fields, userpreference.FieldSavedSearch)
	}
	if m.created_at != nil {
		fields = append(fields, userpreference.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userpreference.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserPreferenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userpreference.FieldUserID:
		return m.UserID()
	case userpreference.FieldCountry:
		return m.Country()
	case userpreference.FieldCurrency:
		return m.Currency()
	case userpreference.FieldLanguage:
		return m.Language()
	case userpreference.FieldTheme:
		return m.Theme()
	case userpreference.FieldSidebarOpen:
		return m.SidebarOpen()
	case userpreference.FieldLastActiveSessionID:
		return m.LastActiveSessionID()
	case userpreference.FieldSavedSearch:
		return m.SavedSearch()
	case userpreference.FieldCreatedAt:
		return m.CreatedAt()
	case userpreference.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserPreferenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userpreference.FieldUserID:
		return m.OldUserID(ctx)
	case userpreference.FieldCountry:
		return m.OldCountry(ctx)
	case userpreference.FieldCurrency:
		return m.OldCurrency(ctx)
	case userpreference.FieldLanguage:
		return m.OldLanguage(ctx)
	case userpreference.FieldTheme:
		return m.OldTheme(ctx)
	case userpreference.FieldSidebarOpen:
		return m.OldSidebarOpen(ctx)
	case userpreference.FieldLastActiveSessionID:
		return m.OldLastActiveSessionID(ctx)
	case userpreference.FieldSavedSearch:
		return m.OldSavedSearch(ctx)
	case userpreference.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userpreference.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserPreference field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPreferenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userpreference.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userpreference.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case userpreference.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case userpreference.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case userpreference.FieldTheme:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTheme(v)
		return nil
	case userpreference.FieldSidebarOpen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSidebarOpen(v)
		return nil
	case userpreference.FieldLastActiveSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastActiveSessionID(v)
		return nil
	case userpreference.FieldSavedSearch:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSavedSearch(v)
		return nil
	case userpreference.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userpreference.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserPreference field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserPreferenceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserPreferenceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPreferenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserPreference numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserPreferenceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userpreference.FieldCountry) {
		fields = append(fields, userpreference.FieldCountry)
	}
	if m.FieldCleared(userpreference.FieldCurrency) {
		fields = append(fields, userpreference.FieldCurrency)
	}
	if m.FieldCleared(userpreference.FieldLanguage) {
		fields = append(fields, userpreference.FieldLanguage)
	}
	if m.FieldCleared(userpreference.FieldTheme) {
		fields = append(fields, userpreference.FieldTheme)
	}
	if m.FieldCleared(userpreference.FieldSidebarOpen) {
		fields = append(fields, userpreference.FieldSidebarOpen)
	}
	if m.FieldCleared(userpreference.FieldLastActiveSessionID) {
		fields = append(fields, userpreference.FieldLastActiveSessionID)
	}
	if m.FieldCleared(userpreference.FieldSavedSearch) {
		fields = append(fields, userpreference.FieldSavedSearch)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserPreferenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserPreferenceMutation) ClearField(name string) error {
	switch name {
	case userpreference.FieldCountry:
		m.ClearCountry()
		return nil
	case userpreference.FieldCurrency:
		m.ClearCurrency()
		return nil
	case userpreference.FieldLanguage:
		m.ClearLanguage()
		return nil
	case userpreference.FieldTheme:
		m.ClearTheme()
		return nil
	case userpreference.FieldSidebarOpen:
		m.ClearSidebarOpen()
		return nil
	case userpreference.FieldLastActiveSessionID:
		m.ClearLastActiveSessionID()
		return nil
	case userpreference.FieldSavedSearch:
		m.ClearSavedSearch()
		return nil
	}
	return fmt.Errorf("unknown UserPreference nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserPreferenceMutation) ResetField(name string) error {
	switch name {
	case userpreference.FieldUserID:
		m.ResetUserID()
		return nil
	case userpreference.FieldCountry:
		m.ResetCountry()
		return nil
	case userpreference.FieldCurrency:
		m.ResetCurrency()
		return nil
	case userpreference.FieldLanguage:
		m.ResetLanguage()
		return nil
	case userpreference.FieldTheme:
		m.ResetTheme()
		return nil
	case userpreference.FieldSidebarOpen:
		m.ResetSidebarOpen()
		return nil
	case userpreference.FieldLastActiveSessionID:
		m.ResetLastActiveSessionID()
		return nil
	case userpreference.FieldSavedSearch:
		m.ResetSavedSearch()
		return nil
	case userpreference.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userpreference.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserPreference field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserPreferenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userpreference.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserPreferenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userpreference.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserPreferenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserPreferenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserPreferenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userpreference.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserPreferenceMutation) EdgeCleared(name string) bool {
	switch name {
	case userpreference.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserPreferenceMutation) ClearEdge(name string) error {
	switch name {
	case userpreference.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserPreference unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserPreferenceMutation) ResetEdge(name string) error {
	switch name {
	case userpreference.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserPreference edge %s", name)
}
