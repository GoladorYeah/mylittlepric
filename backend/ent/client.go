// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"mylittleprice/ent/migrate"

	"mylittleprice/ent/chatsession"
	"mylittleprice/ent/conversationanalytics"
	"mylittleprice/ent/message"
	"mylittleprice/ent/productinteraction"
	"mylittleprice/ent/searchhistory"
	"mylittleprice/ent/user"
	"mylittleprice/ent/userbehaviorprofile"
	"mylittleprice/ent/userpreference"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// ChatSession is the client for interacting with the ChatSession builders.
	ChatSession *ChatSessionClient
	// ConversationAnalytics is the client for interacting with the ConversationAnalytics builders.
	ConversationAnalytics *ConversationAnalyticsClient
	// Message is the client for interacting with the Message builders.
	Message *MessageClient
	// ProductInteraction is the client for interacting with the ProductInteraction builders.
	ProductInteraction *ProductInteractionClient
	// SearchHistory is the client for interacting with the SearchHistory builders.
	SearchHistory *SearchHistoryClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserBehaviorProfile is the client for interacting with the UserBehaviorProfile builders.
	UserBehaviorProfile *UserBehaviorProfileClient
	// UserPreference is the client for interacting with the UserPreference builders.
	UserPreference *UserPreferenceClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.ChatSession = NewChatSessionClient(c.config)
	c.ConversationAnalytics = NewConversationAnalyticsClient(c.config)
	c.Message = NewMessageClient(c.config)
	c.ProductInteraction = NewProductInteractionClient(c.config)
	c.SearchHistory = NewSearchHistoryClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserBehaviorProfile = NewUserBehaviorProfileClient(c.config)
	c.UserPreference = NewUserPreferenceClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		ChatSession:           NewChatSessionClient(cfg),
		ConversationAnalytics: NewConversationAnalyticsClient(cfg),
		Message:               NewMessageClient(cfg),
		ProductInteraction:    NewProductInteractionClient(cfg),
		SearchHistory:         NewSearchHistoryClient(cfg),
		User:                  NewUserClient(cfg),
		UserBehaviorProfile:   NewUserBehaviorProfileClient(cfg),
		UserPreference:        NewUserPreferenceClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		ChatSession:           NewChatSessionClient(cfg),
		ConversationAnalytics: NewConversationAnalyticsClient(cfg),
		Message:               NewMessageClient(cfg),
		ProductInteraction:    NewProductInteractionClient(cfg),
		SearchHistory:         NewSearchHistoryClient(cfg),
		User:                  NewUserClient(cfg),
		UserBehaviorProfile:   NewUserBehaviorProfileClient(cfg),
		UserPreference:        NewUserPreferenceClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		ChatSession.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.ChatSession, c.ConversationAnalytics, c.Message, c.ProductInteraction,
		c.SearchHistory, c.User, c.UserBehaviorProfile, c.UserPreference,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.ChatSession, c.ConversationAnalytics, c.Message, c.ProductInteraction,
		c.SearchHistory, c.User, c.UserBehaviorProfile, c.UserPreference,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ChatSessionMutation:
		return c.ChatSession.mutate(ctx, m)
	case *ConversationAnalyticsMutation:
		return c.ConversationAnalytics.mutate(ctx, m)
	case *MessageMutation:
		return c.Message.mutate(ctx, m)
	case *ProductInteractionMutation:
		return c.ProductInteraction.mutate(ctx, m)
	case *SearchHistoryMutation:
		return c.SearchHistory.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserBehaviorProfileMutation:
		return c.UserBehaviorProfile.mutate(ctx, m)
	case *UserPreferenceMutation:
		return c.UserPreference.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ChatSessionClient is a client for the ChatSession schema.
type ChatSessionClient struct {
	config
}

// NewChatSessionClient returns a client for the ChatSession from the given config.
func NewChatSessionClient(c config) *ChatSessionClient {
	return &ChatSessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `chatsession.Hooks(f(g(h())))`.
func (c *ChatSessionClient) Use(hooks ...Hook) {
	c.hooks.ChatSession = append(c.hooks.ChatSession, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `chatsession.Intercept(f(g(h())))`.
func (c *ChatSessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.ChatSession = append(c.inters.ChatSession, interceptors...)
}

// Create returns a builder for creating a ChatSession entity.
func (c *ChatSessionClient) Create() *ChatSessionCreate {
	mutation := newChatSessionMutation(c.config, OpCreate)
	return &ChatSessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ChatSession entities.
func (c *ChatSessionClient) CreateBulk(builders ...*ChatSessionCreate) *ChatSessionCreateBulk {
	return &ChatSessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ChatSessionClient) MapCreateBulk(slice any, setFunc func(*ChatSessionCreate, int)) *ChatSessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ChatSessionCreateBulk{err: fmt.Errorf("calling to ChatSessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ChatSessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ChatSessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ChatSession.
func (c *ChatSessionClient) Update() *ChatSessionUpdate {
	mutation := newChatSessionMutation(c.config, OpUpdate)
	return &ChatSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChatSessionClient) UpdateOne(_m *ChatSession) *ChatSessionUpdateOne {
	mutation := newChatSessionMutation(c.config, OpUpdateOne, withChatSession(_m))
	return &ChatSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChatSessionClient) UpdateOneID(id uuid.UUID) *ChatSessionUpdateOne {
	mutation := newChatSessionMutation(c.config, OpUpdateOne, withChatSessionID(id))
	return &ChatSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ChatSession.
func (c *ChatSessionClient) Delete() *ChatSessionDelete {
	mutation := newChatSessionMutation(c.config, OpDelete)
	return &ChatSessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChatSessionClient) DeleteOne(_m *ChatSession) *ChatSessionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChatSessionClient) DeleteOneID(id uuid.UUID) *ChatSessionDeleteOne {
	builder := c.Delete().Where(chatsession.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChatSessionDeleteOne{builder}
}

// Query returns a query builder for ChatSession.
func (c *ChatSessionClient) Query() *ChatSessionQuery {
	return &ChatSessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeChatSession},
		inters: c.Interceptors(),
	}
}

// Get returns a ChatSession entity by its id.
func (c *ChatSessionClient) Get(ctx context.Context, id uuid.UUID) (*ChatSession, error) {
	return c.Query().Where(chatsession.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChatSessionClient) GetX(ctx context.Context, id uuid.UUID) *ChatSession {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a ChatSession.
func (c *ChatSessionClient) QueryUser(_m *ChatSession) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(chatsession.Table, chatsession.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, chatsession.UserTable, chatsession.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessages queries the messages edge of a ChatSession.
func (c *ChatSessionClient) QueryMessages(_m *ChatSession) *MessageQuery {
	query := (&MessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(chatsession.Table, chatsession.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, chatsession.MessagesTable, chatsession.MessagesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnalytics queries the analytics edge of a ChatSession.
func (c *ChatSessionClient) QueryAnalytics(_m *ChatSession) *ConversationAnalyticsQuery {
	query := (&ConversationAnalyticsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(chatsession.Table, chatsession.FieldID, id),
			sqlgraph.To(conversationanalytics.Table, conversationanalytics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, chatsession.AnalyticsTable, chatsession.AnalyticsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ChatSessionClient) Hooks() []Hook {
	return c.hooks.ChatSession
}

// Interceptors returns the client interceptors.
func (c *ChatSessionClient) Interceptors() []Interceptor {
	return c.inters.ChatSession
}

func (c *ChatSessionClient) mutate(ctx context.Context, m *ChatSessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ChatSessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ChatSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ChatSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ChatSessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ChatSession mutation op: %q", m.Op())
	}
}

// ConversationAnalyticsClient is a client for the ConversationAnalytics schema.
type ConversationAnalyticsClient struct {
	config
}

// NewConversationAnalyticsClient returns a client for the ConversationAnalytics from the given config.
func NewConversationAnalyticsClient(c config) *ConversationAnalyticsClient {
	return &ConversationAnalyticsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `conversationanalytics.Hooks(f(g(h())))`.
func (c *ConversationAnalyticsClient) Use(hooks ...Hook) {
	c.hooks.ConversationAnalytics = append(c.hooks.ConversationAnalytics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `conversationanalytics.Intercept(f(g(h())))`.
func (c *ConversationAnalyticsClient) Intercept(interceptors ...Interceptor) {
	c.inters.ConversationAnalytics = append(c.inters.ConversationAnalytics, interceptors...)
}

// Create returns a builder for creating a ConversationAnalytics entity.
func (c *ConversationAnalyticsClient) Create() *ConversationAnalyticsCreate {
	mutation := newConversationAnalyticsMutation(c.config, OpCreate)
	return &ConversationAnalyticsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ConversationAnalytics entities.
func (c *ConversationAnalyticsClient) CreateBulk(builders ...*ConversationAnalyticsCreate) *ConversationAnalyticsCreateBulk {
	return &ConversationAnalyticsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ConversationAnalyticsClient) MapCreateBulk(slice any, setFunc func(*ConversationAnalyticsCreate, int)) *ConversationAnalyticsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ConversationAnalyticsCreateBulk{err: fmt.Errorf("calling to ConversationAnalyticsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ConversationAnalyticsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ConversationAnalyticsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ConversationAnalytics.
func (c *ConversationAnalyticsClient) Update() *ConversationAnalyticsUpdate {
	mutation := newConversationAnalyticsMutation(c.config, OpUpdate)
	return &ConversationAnalyticsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConversationAnalyticsClient) UpdateOne(_m *ConversationAnalytics) *ConversationAnalyticsUpdateOne {
	mutation := newConversationAnalyticsMutation(c.config, OpUpdateOne, withConversationAnalytics(_m))
	return &ConversationAnalyticsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConversationAnalyticsClient) UpdateOneID(id uuid.UUID) *ConversationAnalyticsUpdateOne {
	mutation := newConversationAnalyticsMutation(c.config, OpUpdateOne, withConversationAnalyticsID(id))
	return &ConversationAnalyticsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ConversationAnalytics.
func (c *ConversationAnalyticsClient) Delete() *ConversationAnalyticsDelete {
	mutation := newConversationAnalyticsMutation(c.config, OpDelete)
	return &ConversationAnalyticsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConversationAnalyticsClient) DeleteOne(_m *ConversationAnalytics) *ConversationAnalyticsDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConversationAnalyticsClient) DeleteOneID(id uuid.UUID) *ConversationAnalyticsDeleteOne {
	builder := c.Delete().Where(conversationanalytics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConversationAnalyticsDeleteOne{builder}
}

// Query returns a query builder for ConversationAnalytics.
func (c *ConversationAnalyticsClient) Query() *ConversationAnalyticsQuery {
	return &ConversationAnalyticsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeConversationAnalytics},
		inters: c.Interceptors(),
	}
}

// Get returns a ConversationAnalytics entity by its id.
func (c *ConversationAnalyticsClient) Get(ctx context.Context, id uuid.UUID) (*ConversationAnalytics, error) {
	return c.Query().Where(conversationanalytics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConversationAnalyticsClient) GetX(ctx context.Context, id uuid.UUID) *ConversationAnalytics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a ConversationAnalytics.
func (c *ConversationAnalyticsClient) QueryUser(_m *ConversationAnalytics) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(conversationanalytics.Table, conversationanalytics.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, conversationanalytics.UserTable, conversationanalytics.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySession queries the session edge of a ConversationAnalytics.
func (c *ConversationAnalyticsClient) QuerySession(_m *ConversationAnalytics) *ChatSessionQuery {
	query := (&ChatSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(conversationanalytics.Table, conversationanalytics.FieldID, id),
			sqlgraph.To(chatsession.Table, chatsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, conversationanalytics.SessionTable, conversationanalytics.SessionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ConversationAnalyticsClient) Hooks() []Hook {
	return c.hooks.ConversationAnalytics
}

// Interceptors returns the client interceptors.
func (c *ConversationAnalyticsClient) Interceptors() []Interceptor {
	return c.inters.ConversationAnalytics
}

func (c *ConversationAnalyticsClient) mutate(ctx context.Context, m *ConversationAnalyticsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ConversationAnalyticsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ConversationAnalyticsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ConversationAnalyticsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ConversationAnalyticsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ConversationAnalytics mutation op: %q", m.Op())
	}
}

// MessageClient is a client for the Message schema.
type MessageClient struct {
	config
}

// NewMessageClient returns a client for the Message from the given config.
func NewMessageClient(c config) *MessageClient {
	return &MessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `message.Hooks(f(g(h())))`.
func (c *MessageClient) Use(hooks ...Hook) {
	c.hooks.Message = append(c.hooks.Message, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `message.Intercept(f(g(h())))`.
func (c *MessageClient) Intercept(interceptors ...Interceptor) {
	c.inters.Message = append(c.inters.Message, interceptors...)
}

// Create returns a builder for creating a Message entity.
func (c *MessageClient) Create() *MessageCreate {
	mutation := newMessageMutation(c.config, OpCreate)
	return &MessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Message entities.
func (c *MessageClient) CreateBulk(builders ...*MessageCreate) *MessageCreateBulk {
	return &MessageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageClient) MapCreateBulk(slice any, setFunc func(*MessageCreate, int)) *MessageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageCreateBulk{err: fmt.Errorf("calling to MessageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Message.
func (c *MessageClient) Update() *MessageUpdate {
	mutation := newMessageMutation(c.config, OpUpdate)
	return &MessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageClient) UpdateOne(_m *Message) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessage(_m))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageClient) UpdateOneID(id uuid.UUID) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessageID(id))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Message.
func (c *MessageClient) Delete() *MessageDelete {
	mutation := newMessageMutation(c.config, OpDelete)
	return &MessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageClient) DeleteOne(_m *Message) *MessageDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageClient) DeleteOneID(id uuid.UUID) *MessageDeleteOne {
	builder := c.Delete().Where(message.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageDeleteOne{builder}
}

// Query returns a query builder for Message.
func (c *MessageClient) Query() *MessageQuery {
	return &MessageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessage},
		inters: c.Interceptors(),
	}
}

// Get returns a Message entity by its id.
func (c *MessageClient) Get(ctx context.Context, id uuid.UUID) (*Message, error) {
	return c.Query().Where(message.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageClient) GetX(ctx context.Context, id uuid.UUID) *Message {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySession queries the session edge of a Message.
func (c *MessageClient) QuerySession(_m *Message) *ChatSessionQuery {
	query := (&ChatSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(chatsession.Table, chatsession.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, message.SessionTable, message.SessionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MessageClient) Hooks() []Hook {
	return c.hooks.Message
}

// Interceptors returns the client interceptors.
func (c *MessageClient) Interceptors() []Interceptor {
	return c.inters.Message
}

func (c *MessageClient) mutate(ctx context.Context, m *MessageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Message mutation op: %q", m.Op())
	}
}

// ProductInteractionClient is a client for the ProductInteraction schema.
type ProductInteractionClient struct {
	config
}

// NewProductInteractionClient returns a client for the ProductInteraction from the given config.
func NewProductInteractionClient(c config) *ProductInteractionClient {
	return &ProductInteractionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `productinteraction.Hooks(f(g(h())))`.
func (c *ProductInteractionClient) Use(hooks ...Hook) {
	c.hooks.ProductInteraction = append(c.hooks.ProductInteraction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `productinteraction.Intercept(f(g(h())))`.
func (c *ProductInteractionClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductInteraction = append(c.inters.ProductInteraction, interceptors...)
}

// Create returns a builder for creating a ProductInteraction entity.
func (c *ProductInteractionClient) Create() *ProductInteractionCreate {
	mutation := newProductInteractionMutation(c.config, OpCreate)
	return &ProductInteractionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductInteraction entities.
func (c *ProductInteractionClient) CreateBulk(builders ...*ProductInteractionCreate) *ProductInteractionCreateBulk {
	return &ProductInteractionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductInteractionClient) MapCreateBulk(slice any, setFunc func(*ProductInteractionCreate, int)) *ProductInteractionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductInteractionCreateBulk{err: fmt.Errorf("calling to ProductInteractionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductInteractionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductInteractionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductInteraction.
func (c *ProductInteractionClient) Update() *ProductInteractionUpdate {
	mutation := newProductInteractionMutation(c.config, OpUpdate)
	return &ProductInteractionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductInteractionClient) UpdateOne(_m *ProductInteraction) *ProductInteractionUpdateOne {
	mutation := newProductInteractionMutation(c.config, OpUpdateOne, withProductInteraction(_m))
	return &ProductInteractionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductInteractionClient) UpdateOneID(id uuid.UUID) *ProductInteractionUpdateOne {
	mutation := newProductInteractionMutation(c.config, OpUpdateOne, withProductInteractionID(id))
	return &ProductInteractionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductInteraction.
func (c *ProductInteractionClient) Delete() *ProductInteractionDelete {
	mutation := newProductInteractionMutation(c.config, OpDelete)
	return &ProductInteractionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductInteractionClient) DeleteOne(_m *ProductInteraction) *ProductInteractionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductInteractionClient) DeleteOneID(id uuid.UUID) *ProductInteractionDeleteOne {
	builder := c.Delete().Where(productinteraction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductInteractionDeleteOne{builder}
}

// Query returns a query builder for ProductInteraction.
func (c *ProductInteractionClient) Query() *ProductInteractionQuery {
	return &ProductInteractionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductInteraction},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductInteraction entity by its id.
func (c *ProductInteractionClient) Get(ctx context.Context, id uuid.UUID) (*ProductInteraction, error) {
	return c.Query().Where(productinteraction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductInteractionClient) GetX(ctx context.Context, id uuid.UUID) *ProductInteraction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a ProductInteraction.
func (c *ProductInteractionClient) QueryUser(_m *ProductInteraction) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productinteraction.Table, productinteraction.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, productinteraction.UserTable, productinteraction.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductInteractionClient) Hooks() []Hook {
	return c.hooks.ProductInteraction
}

// Interceptors returns the client interceptors.
func (c *ProductInteractionClient) Interceptors() []Interceptor {
	return c.inters.ProductInteraction
}

func (c *ProductInteractionClient) mutate(ctx context.Context, m *ProductInteractionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductInteractionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductInteractionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductInteractionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductInteractionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductInteraction mutation op: %q", m.Op())
	}
}

// SearchHistoryClient is a client for the SearchHistory schema.
type SearchHistoryClient struct {
	config
}

// NewSearchHistoryClient returns a client for the SearchHistory from the given config.
func NewSearchHistoryClient(c config) *SearchHistoryClient {
	return &SearchHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `searchhistory.Hooks(f(g(h())))`.
func (c *SearchHistoryClient) Use(hooks ...Hook) {
	c.hooks.SearchHistory = append(c.hooks.SearchHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `searchhistory.Intercept(f(g(h())))`.
func (c *SearchHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.SearchHistory = append(c.inters.SearchHistory, interceptors...)
}

// Create returns a builder for creating a SearchHistory entity.
func (c *SearchHistoryClient) Create() *SearchHistoryCreate {
	mutation := newSearchHistoryMutation(c.config, OpCreate)
	return &SearchHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SearchHistory entities.
func (c *SearchHistoryClient) CreateBulk(builders ...*SearchHistoryCreate) *SearchHistoryCreateBulk {
	return &SearchHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SearchHistoryClient) MapCreateBulk(slice any, setFunc func(*SearchHistoryCreate, int)) *SearchHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SearchHistoryCreateBulk{err: fmt.Errorf("calling to SearchHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SearchHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SearchHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SearchHistory.
func (c *SearchHistoryClient) Update() *SearchHistoryUpdate {
	mutation := newSearchHistoryMutation(c.config, OpUpdate)
	return &SearchHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SearchHistoryClient) UpdateOne(_m *SearchHistory) *SearchHistoryUpdateOne {
	mutation := newSearchHistoryMutation(c.config, OpUpdateOne, withSearchHistory(_m))
	return &SearchHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SearchHistoryClient) UpdateOneID(id uuid.UUID) *SearchHistoryUpdateOne {
	mutation := newSearchHistoryMutation(c.config, OpUpdateOne, withSearchHistoryID(id))
	return &SearchHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SearchHistory.
func (c *SearchHistoryClient) Delete() *SearchHistoryDelete {
	mutation := newSearchHistoryMutation(c.config, OpDelete)
	return &SearchHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SearchHistoryClient) DeleteOne(_m *SearchHistory) *SearchHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SearchHistoryClient) DeleteOneID(id uuid.UUID) *SearchHistoryDeleteOne {
	builder := c.Delete().Where(searchhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SearchHistoryDeleteOne{builder}
}

// Query returns a query builder for SearchHistory.
func (c *SearchHistoryClient) Query() *SearchHistoryQuery {
	return &SearchHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSearchHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a SearchHistory entity by its id.
func (c *SearchHistoryClient) Get(ctx context.Context, id uuid.UUID) (*SearchHistory, error) {
	return c.Query().Where(searchhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SearchHistoryClient) GetX(ctx context.Context, id uuid.UUID) *SearchHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a SearchHistory.
func (c *SearchHistoryClient) QueryUser(_m *SearchHistory) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(searchhistory.Table, searchhistory.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, searchhistory.UserTable, searchhistory.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SearchHistoryClient) Hooks() []Hook {
	return c.hooks.SearchHistory
}

// Interceptors returns the client interceptors.
func (c *SearchHistoryClient) Interceptors() []Interceptor {
	return c.inters.SearchHistory
}

func (c *SearchHistoryClient) mutate(ctx context.Context, m *SearchHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SearchHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SearchHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SearchHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SearchHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SearchHistory mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySessions queries the sessions edge of a User.
func (c *UserClient) QuerySessions(_m *User) *ChatSessionQuery {
	query := (&ChatSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(chatsession.Table, chatsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SessionsTable, user.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySearchHistory queries the search_history edge of a User.
func (c *UserClient) QuerySearchHistory(_m *User) *SearchHistoryQuery {
	query := (&SearchHistoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(searchhistory.Table, searchhistory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SearchHistoryTable, user.SearchHistoryColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPreferences queries the preferences edge of a User.
func (c *UserClient) QueryPreferences(_m *User) *UserPreferenceQuery {
	query := (&UserPreferenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userpreference.Table, userpreference.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.PreferencesTable, user.PreferencesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBehaviorProfile queries the behavior_profile edge of a User.
func (c *UserClient) QueryBehaviorProfile(_m *User) *UserBehaviorProfileQuery {
	query := (&UserBehaviorProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userbehaviorprofile.Table, userbehaviorprofile.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.BehaviorProfileTable, user.BehaviorProfileColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConversationAnalytics queries the conversation_analytics edge of a User.
func (c *UserClient) QueryConversationAnalytics(_m *User) *ConversationAnalyticsQuery {
	query := (&ConversationAnalyticsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(conversationanalytics.Table, conversationanalytics.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ConversationAnalyticsTable, user.ConversationAnalyticsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductInteractions queries the product_interactions edge of a User.
func (c *UserClient) QueryProductInteractions(_m *User) *ProductInteractionQuery {
	query := (&ProductInteractionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(productinteraction.Table, productinteraction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ProductInteractionsTable, user.ProductInteractionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserBehaviorProfileClient is a client for the UserBehaviorProfile schema.
type UserBehaviorProfileClient struct {
	config
}

// NewUserBehaviorProfileClient returns a client for the UserBehaviorProfile from the given config.
func NewUserBehaviorProfileClient(c config) *UserBehaviorProfileClient {
	return &UserBehaviorProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userbehaviorprofile.Hooks(f(g(h())))`.
func (c *UserBehaviorProfileClient) Use(hooks ...Hook) {
	c.hooks.UserBehaviorProfile = append(c.hooks.UserBehaviorProfile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userbehaviorprofile.Intercept(f(g(h())))`.
func (c *UserBehaviorProfileClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserBehaviorProfile = append(c.inters.UserBehaviorProfile, interceptors...)
}

// Create returns a builder for creating a UserBehaviorProfile entity.
func (c *UserBehaviorProfileClient) Create() *UserBehaviorProfileCreate {
	mutation := newUserBehaviorProfileMutation(c.config, OpCreate)
	return &UserBehaviorProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserBehaviorProfile entities.
func (c *UserBehaviorProfileClient) CreateBulk(builders ...*UserBehaviorProfileCreate) *UserBehaviorProfileCreateBulk {
	return &UserBehaviorProfileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserBehaviorProfileClient) MapCreateBulk(slice any, setFunc func(*UserBehaviorProfileCreate, int)) *UserBehaviorProfileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserBehaviorProfileCreateBulk{err: fmt.Errorf("calling to UserBehaviorProfileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserBehaviorProfileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserBehaviorProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserBehaviorProfile.
func (c *UserBehaviorProfileClient) Update() *UserBehaviorProfileUpdate {
	mutation := newUserBehaviorProfileMutation(c.config, OpUpdate)
	return &UserBehaviorProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserBehaviorProfileClient) UpdateOne(_m *UserBehaviorProfile) *UserBehaviorProfileUpdateOne {
	mutation := newUserBehaviorProfileMutation(c.config, OpUpdateOne, withUserBehaviorProfile(_m))
	return &UserBehaviorProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserBehaviorProfileClient) UpdateOneID(id uuid.UUID) *UserBehaviorProfileUpdateOne {
	mutation := newUserBehaviorProfileMutation(c.config, OpUpdateOne, withUserBehaviorProfileID(id))
	return &UserBehaviorProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserBehaviorProfile.
func (c *UserBehaviorProfileClient) Delete() *UserBehaviorProfileDelete {
	mutation := newUserBehaviorProfileMutation(c.config, OpDelete)
	return &UserBehaviorProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserBehaviorProfileClient) DeleteOne(_m *UserBehaviorProfile) *UserBehaviorProfileDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserBehaviorProfileClient) DeleteOneID(id uuid.UUID) *UserBehaviorProfileDeleteOne {
	builder := c.Delete().Where(userbehaviorprofile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserBehaviorProfileDeleteOne{builder}
}

// Query returns a query builder for UserBehaviorProfile.
func (c *UserBehaviorProfileClient) Query() *UserBehaviorProfileQuery {
	return &UserBehaviorProfileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserBehaviorProfile},
		inters: c.Interceptors(),
	}
}

// Get returns a UserBehaviorProfile entity by its id.
func (c *UserBehaviorProfileClient) Get(ctx context.Context, id uuid.UUID) (*UserBehaviorProfile, error) {
	return c.Query().Where(userbehaviorprofile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserBehaviorProfileClient) GetX(ctx context.Context, id uuid.UUID) *UserBehaviorProfile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserBehaviorProfile.
func (c *UserBehaviorProfileClient) QueryUser(_m *UserBehaviorProfile) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userbehaviorprofile.Table, userbehaviorprofile.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, userbehaviorprofile.UserTable, userbehaviorprofile.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserBehaviorProfileClient) Hooks() []Hook {
	return c.hooks.UserBehaviorProfile
}

// Interceptors returns the client interceptors.
func (c *UserBehaviorProfileClient) Interceptors() []Interceptor {
	return c.inters.UserBehaviorProfile
}

func (c *UserBehaviorProfileClient) mutate(ctx context.Context, m *UserBehaviorProfileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserBehaviorProfileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserBehaviorProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserBehaviorProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserBehaviorProfileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserBehaviorProfile mutation op: %q", m.Op())
	}
}

// UserPreferenceClient is a client for the UserPreference schema.
type UserPreferenceClient struct {
	config
}

// NewUserPreferenceClient returns a client for the UserPreference from the given config.
func NewUserPreferenceClient(c config) *UserPreferenceClient {
	return &UserPreferenceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userpreference.Hooks(f(g(h())))`.
func (c *UserPreferenceClient) Use(hooks ...Hook) {
	c.hooks.UserPreference = append(c.hooks.UserPreference, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userpreference.Intercept(f(g(h())))`.
func (c *UserPreferenceClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserPreference = append(c.inters.UserPreference, interceptors...)
}

// Create returns a builder for creating a UserPreference entity.
func (c *UserPreferenceClient) Create() *UserPreferenceCreate {
	mutation := newUserPreferenceMutation(c.config, OpCreate)
	return &UserPreferenceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserPreference entities.
func (c *UserPreferenceClient) CreateBulk(builders ...*UserPreferenceCreate) *UserPreferenceCreateBulk {
	return &UserPreferenceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserPreferenceClient) MapCreateBulk(slice any, setFunc func(*UserPreferenceCreate, int)) *UserPreferenceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserPreferenceCreateBulk{err: fmt.Errorf("calling to UserPreferenceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserPreferenceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserPreferenceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserPreference.
func (c *UserPreferenceClient) Update() *UserPreferenceUpdate {
	mutation := newUserPreferenceMutation(c.config, OpUpdate)
	return &UserPreferenceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserPreferenceClient) UpdateOne(_m *UserPreference) *UserPreferenceUpdateOne {
	mutation := newUserPreferenceMutation(c.config, OpUpdateOne, withUserPreference(_m))
	return &UserPreferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserPreferenceClient) UpdateOneID(id uuid.UUID) *UserPreferenceUpdateOne {
	mutation := newUserPreferenceMutation(c.config, OpUpdateOne, withUserPreferenceID(id))
	return &UserPreferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserPreference.
func (c *UserPreferenceClient) Delete() *UserPreferenceDelete {
	mutation := newUserPreferenceMutation(c.config, OpDelete)
	return &UserPreferenceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserPreferenceClient) DeleteOne(_m *UserPreference) *UserPreferenceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserPreferenceClient) DeleteOneID(id uuid.UUID) *UserPreferenceDeleteOne {
	builder := c.Delete().Where(userpreference.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserPreferenceDeleteOne{builder}
}

// Query returns a query builder for UserPreference.
func (c *UserPreferenceClient) Query() *UserPreferenceQuery {
	return &UserPreferenceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserPreference},
		inters: c.Interceptors(),
	}
}

// Get returns a UserPreference entity by its id.
func (c *UserPreferenceClient) Get(ctx context.Context, id uuid.UUID) (*UserPreference, error) {
	return c.Query().Where(userpreference.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserPreferenceClient) GetX(ctx context.Context, id uuid.UUID) *UserPreference {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserPreference.
func (c *UserPreferenceClient) QueryUser(_m *UserPreference) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userpreference.Table, userpreference.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, userpreference.UserTable, userpreference.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserPreferenceClient) Hooks() []Hook {
	return c.hooks.UserPreference
}

// Interceptors returns the client interceptors.
func (c *UserPreferenceClient) Interceptors() []Interceptor {
	return c.inters.UserPreference
}

func (c *UserPreferenceClient) mutate(ctx context.Context, m *UserPreferenceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserPreferenceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserPreferenceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserPreferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserPreferenceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserPreference mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		ChatSession, ConversationAnalytics, Message, ProductInteraction, SearchHistory,
		User, UserBehaviorProfile, UserPreference []ent.Hook
	}
	inters struct {
		ChatSession, ConversationAnalytics, Message, ProductInteraction, SearchHistory,
		User, UserBehaviorProfile, UserPreference []ent.Interceptor
	}
)
